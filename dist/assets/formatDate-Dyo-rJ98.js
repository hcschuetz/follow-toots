import{t as e}from"./database-BGZyZyq9.js";import{r as t}from"./signals-core.module-PplyFw7G.js";var n=(e,...t)=>Object.assign(e,...t.map(t=>typeof t==`function`?t(e):t)),r=(e,t)=>{let r=n(new BroadcastChannel(e),{onmessage(e){let[n,...r]=e.data;t[n](...r)}});return new Proxy({},{get:(e,n)=>(...e)=>{r.postMessage([n,...e]),t[n](...e)}})},i=e=>e.edited_at?`${e.id}@${e.edited_at}`:e.id,a=await e,o=r(`followToots`,{async updatedTreeOverview(e){console.log(`overview`,await a.get(`treeOverview`,e))},async updatedTree(e){console.log(`details`,await a.get(`treeDetails`,e))},async deletedTree(e){console.log(`deleted`,e)},cleared(){console.log(`cleared`)}});async function s(e,t){try{let r=`${e}/${t}`,i=`https://${e}/api/v1/statuses/${t}`,s=i+`/context`,c=`

* Does the instance "${e}"
  have a toot with id "${t}"?
* Is that toot public or accessible with
  an access token you have provided for
  ${e}?
* And of course: Is there network connectivity
  between you and ${e}?
`;{let{store:i}=a.transaction(`treeOverview`,`readwrite`);await i.put(n(await i.get(r)??{seenIds:new Set},{key:r,instance:e,id:t,lastRequestDate:new Date}))}o.updatedTreeOverview(r);let u={},f=(await a.get(`accessTokens`,e))?.token;f!==void 0&&(u.headers={Authorization:`Bearer ${f}`});let p=await fetch(i,u);if(!p.ok)throw alert(`Could not fetch toot ${t} from ${e} (HTTP status code ${p.status}).${c}`),`Could not fetch toot ${t} from ${e}.`;let m=await p.json(),h=await fetch(s,u);if(!h.ok)throw alert(`Could not fetch context (replies) for toot ${t} from ${e} (HTTP status code ${p.status}).${c}`),`Could not fetch context (replies) for toot ${t} from ${e}.`;let g=await h.json(),{ancestors:_,descendants:v}=g;v.sort((e,t)=>e.created_at<t.created_at?-1:e.created_at>t.created_at?1:0);{let e=a.transaction([`treeOverview`,`treeDetails`],`readwrite`),t=e.objectStore(`treeOverview`),i=await t.get(r)??{},o=m.spoiler_text||l(m.content);o.length>140&&(o=o.substring(0,140)+`...`),await t.put(n(i,{key:r,lastRetrievalDate:new Date,nToots:_.length+1+v.length,nUnseen:d([..._,m,...v],i.seenIds),rootCreatedAt:new Date(m.created_at),lastCreatedAt:new Date((v.at(-1)??m).created_at),rootAuthor:m.account.display_name,rootAuthorAvatar:m.account.avatar_static,rootAccountEmojis:m.account.emojis,rootAcct:m.account.acct,teaser:o})),await e.objectStore(`treeDetails`).put({key:r,root:m,...g})}o.updatedTree(r)}catch(e){console.error(e)}}var c=new DOMParser;function l(e){return c.parseFromString(e,`text/html`).body.textContent}var u=(e,t)=>e.reduce((e,n)=>e+Number(t(n)),0),d=(e,t)=>u(e,e=>!t.has(i(e)));async function f(e){let t=a.transaction([`treeOverview`,`treeDetails`],`readwrite`),n=await t.objectStore(`treeDetails`).get(e.key);if(!n)return;let{root:r,ancestors:i,descendants:s}=n;await t.objectStore(`treeOverview`).put({...e,nUnseen:d([...i,r,...s],e.seenIds)}),o.updatedTreeOverview(e.key)}async function p({key:e,rootAuthor:t}){if(!confirm(`Really unfollow toot ${e} by ${t}?\n\nThis will not only remove the toot tree from this application, but it will also forget which toots you have already seen.`))return;let n=a.transaction([`treeOverview`,`treeDetails`],`readwrite`);await Promise.all([n.objectStore(`treeOverview`).delete(e),n.objectStore(`treeDetails`).delete(e)]),o.deletedTree(e)}async function m(){let e=await a.getAll(`treeOverview`);await Promise.all(e.map(({instance:e,id:t})=>s(e,t)))}async function h(){if(!confirm(`Really unfollow all toots?`))return;let e=a.transaction([`treeOverview`,`treeDetails`],`readwrite`);await Promise.all([e.objectStore(`treeOverview`).clear(),e.objectStore(`treeDetails`).clear()]),o.cleared()}var g=e=>{let t=new URL(e);switch(t.origin){case`https://phanpy.social`:{let n=t.hash.split(`/`);return b(e,t.pathname===`/`&&t.search===``&&n.length===4&&n[0]===`#`&&n[2]===`s`,n[1],n[3])}case`https://elk.zone`:{let n=t.pathname.split(`/`);return b(e,n.length===4&&n[0]===``&&_.test(n[2])&&t.search===``&&t.hash===``,n[1],n[3])}default:{if(t.pathname.endsWith(`/tree.html`)&&t.hash){let e=new URLSearchParams(`?`+t.hash.substring(1)),n=e.get(`instance`),r=e.get(`id`);if(n&&r&&y.test(r)){if(t.origin===location.origin){alert(`
              While taking over a toot tree from another follow-toots
              installation is supported,
              it was probably a mistake to apply the bookmarklet to
              the same installation.
            `.replaceAll(/\s+/g,` `));return}return[n,r]}}let n=t.pathname.split(`/`);return n[1]===`users`?b(e,n.length===5&&n[0]===``&&v.test(n[2])&&n[3]===`statuses`,t.host,n[4]):(n[1]===`deck`&&n.splice(1,1),b(e,n.length===3&&n[0]===``&&_.test(n[1]),t.host,n[2]))}}},_=/^@[-_a-z0-9]+(@[-_a-z0-9\.]+)?$/i,v=/^[-_a-z0-9]+$/i,y=/^\d+$/,b=(e,t,n,r)=>t&&y.test(r)||confirm(`The URL "${e}" does not look like an URL identifying a single toot.

Use it nevertheless?

(The mastodon instance would be "${n}" and the toot id would be "${r}".)`)?[n,r]:void 0;function*x(e,n=[]){if(n===null){yield e;return}let r=e.indexOf(`:`,0);if(r<0){yield e;return}let i=0;for(;;){let a=r+1,o=e.indexOf(`:`,a);if(o===a){r++;continue}if(o<0)break;let s=e.substring(a,o),c=n.find(e=>e.shortcode===s);if(!c){if(r=o,(r=e.indexOf(`:`,r+1))<0)break;continue}if(yield e.substring(i,r),yield t(`img.custom-emoji`,{src:c.static_url,alt:s,title:s,draggable:!1}),i=o+1,r=e.indexOf(`:`,i),r<0)break}yield e.substring(i)}function S(e){function t(n){for(let r of n.childNodes)if(r instanceof HTMLElement)t(r);else if(r instanceof Text){let t=[...x(r.data,e)];if(t.length===1&&typeof t[0]==`string`)continue;let i=new DocumentFragment;i.append(...t),n.replaceChild(i,r)}else console.error(`unexpected value to emojify:`,r)}return t}var C=e=>e?new Date(e).toLocaleString(`sv`):`-`;export{p as a,m as c,r as d,n as f,g as i,f as l,S as n,h as o,x as r,s,C as t,i as u};