import{t as e}from"./database-BS-gGBMO.js";import{n as t,t as n}from"./H-BDef4IoB.js";var r=(e,...t)=>Object.assign(e,...t.map(t=>typeof t==`function`?t(e):t)),i=(e,t,...r)=>n(`a`,{href:t,target:`_blank`,rel:`noopener noreferrer`},t=>e.split(/[ \.]/).forEach(e=>e&&t.classList.add(e)),...r),a={},o=(e={})=>({keep:!0,attributes:new Map(Object.entries({...a,...e}))}),s=new Map(Object.entries({DIV:o(),SPAN:o({translate:!1,class:!0}),P:o(),BR:o(),I:o(),B:o(),U:o(),STRONG:o(),EM:o(),UL:o(),OL:o(),LI:o()}));function*c(e,t){for(let n of e.attributes)switch(t.get(n.name)){case void 0:console.warn(`skipping attribute`,n);break;case!0:yield n;break;case!1:break}}function*l(e){for(let n of e)if(n instanceof Text)yield n.textContent;else if(n instanceof HTMLAnchorElement)yield i(``,n.href,l(n.childNodes));else if(n instanceof HTMLElement){let e=s.get(n.tagName);switch(e?.keep){case void 0:console.warn(`skipping element`,n);break;case!0:yield t(n.tagName,c(n,e.attributes),l(n.childNodes));break;case!1:break}}else console.warn(`skipping node`,n)}var u=new DOMParser;function*d(e){try{yield*l(u.parseFromString(e,`text/html`).body.childNodes)}catch{yield n(`div.sanitization-error`,`[Error sanitizing "${e}"`)}}var f=(e,t)=>{let n=r(new BroadcastChannel(e),{onmessage(e){let[n,...r]=e.data;t[n](...r)}});return new Proxy({},{get:(e,r)=>(...e)=>{n.postMessage([r,...e]),t[r](...e)}})},p=await e,m=f(`followToots`,{async updatedTreeOverview(e){console.log(`overview`,await p.get(`treeOverview`,e))},async updatedTree(e){console.log(`data`,await p.get(`treeDetails`,e))},async deletedTree(e){console.log(`deleted`,e)},cleared(){console.log(`cleared`)}});async function h(e,t){try{let n=`${e}/${t}`,i=`https://${e}/api/v1/statuses/${t}`,a=i+`/context`,o=`

* Does the instance "${e}"
  have a toot with id "${t}"?
* Is that toot public or accessible with
  an access token you have provided for
  ${e}?
* And of course: Is there network connectivity
  between you and ${e}?
`;{let{store:i}=p.transaction(`treeOverview`,`readwrite`);await i.put(r(await i.get(n)??{closedIds:new Set},{key:n,instance:e,id:t,lastRequestDate:new Date}))}m.updatedTreeOverview(n);let s={},c=(await p.get(`accessTokens`,e))?.token;c!==void 0&&(s.headers={Authorization:`Bearer ${c}`});let l=await fetch(i,s);if(!l.ok)throw alert(`Could not fetch toot ${t} from ${e} (HTTP status code ${l.status}).${o}`),`Could not fetch toot ${t} from ${e}.`;let u=await l.json(),d=await fetch(a,s);if(!d.ok)throw alert(`Could not fetch context (replies) for toot ${t} from ${e} (HTTP status code ${l.status}).${o}`),`Could not fetch context (replies) for toot ${t} from ${e}.`;let f=await d.json(),h=f.descendants.sort((e,t)=>e.created_at<t.created_at?-1:e.created_at>t.created_at?1:0);{let e=p.transaction([`treeOverview`,`treeDetails`],`readwrite`),t=e.objectStore(`treeOverview`),i=await t.get(n)??{},a=u.spoiler_text||g(u.content);a.length>140&&(a=a.substring(0,140)+`...`),await t.put(r(i,{key:n,lastRetrievalDate:new Date,nDescendants:h.length,nOpen:v(u,h,i.closedIds),rootCreatedAt:new Date(u.created_at),lastCreatedAt:new Date((h.at(-1)??u).created_at),rootAuthor:u.account.display_name,rootAuthorAvatar:u.account.avatar_static,rootAccountEmojis:u.account.emojis,rootAcct:u.account.acct,teaser:a,nExpectedDescendants:b(u,h)})),await e.objectStore(`treeDetails`).put({key:n,root:u,ancestors:f.ancestors,descendants:h,tootTree:y(u,h)})}m.updatedTree(n)}catch(e){console.error(e)}}function g(e){let t=new Document().createElement(`div`);return t.append(...d(e)),t.textContent}var _=(e,t)=>e.reduce((e,n)=>e+Number(t(n)),0),v=(e,t,n)=>Number(!n.has(e.id))+_(t,e=>!n.has(e.id));function y(e,t){let n=Object.fromEntries([e,...t].map(e=>[e.id,{toot:e,children:[]}]));for(let e of t)n[e.in_reply_to_id]?.children.push(n[e.id]);return n[e.id]}var b=(e,t)=>t.reduce((e,t)=>e+t.replies_count,e.replies_count);async function x(e){let t=p.transaction([`treeOverview`,`treeDetails`],`readwrite`),n=await t.objectStore(`treeDetails`).get(e.key);n&&(await t.objectStore(`treeOverview`).put({...e,nOpen:v(n.root,n.descendants,e.closedIds)}),m.updatedTreeOverview(e.key))}async function S({key:e,rootAuthor:t}){if(!confirm(`Really unfollow toot ${e} by ${t}?\n\nThis will not only remove the toot tree from this application, but it will also forget which toots you have already closed.`))return;let n=p.transaction([`treeOverview`,`treeDetails`],`readwrite`);await Promise.all([n.objectStore(`treeOverview`).delete(e),n.objectStore(`treeDetails`).delete(e)]),m.deletedTree(e)}async function C(){let e=await p.getAll(`treeOverview`);await Promise.all(e.map(({instance:e,id:t})=>h(e,t)))}async function w(){if(!confirm(`Really unfollow all toots?`))return;let e=p.transaction([`treeOverview`,`treeDetails`],`readwrite`);await Promise.all([e.objectStore(`treeOverview`).clear(),e.objectStore(`treeDetails`).clear()]),m.cleared()}var T=e=>{let t=new URL(e);switch(t.origin){case`https://phanpy.social`:{let n=t.hash.split(`/`);return k(e,t.pathname===`/`&&t.search===``&&n.length===4&&n[0]===`#`&&n[2]===`s`,n[1],n[3])}case`https://elk.zone`:{let n=t.pathname.split(`/`);return k(e,n.length===4&&n[0]===``&&E.test(n[2])&&t.search===``&&t.hash===``,n[1],n[3])}default:{if(t.pathname.endsWith(`/tree.html`)&&t.hash){let e=new URLSearchParams(`?`+t.hash.substring(1)),n=e.get(`instance`),r=e.get(`id`);if(n&&r&&O.test(r)){if(t.origin===location.origin){alert(`
              While taking over a toot tree from another follow-toots
              installation is supported,
              it was probably a mistake to apply the bookmarklet to
              the same installation.
            `.replaceAll(/\s+/g,` `));return}return[n,r]}}let n=t.pathname.split(`/`);return n[1]===`users`?k(e,n.length===5&&n[0]===``&&D.test(n[2])&&n[3]===`statuses`,t.host,n[4]):(n[1]===`deck`&&n.splice(1,1),k(e,n.length===3&&n[0]===``&&E.test(n[1]),t.host,n[2]))}}},E=/^@[-_a-z0-9]+(@[-_a-z0-9\.]+)?$/i,D=/^[-_a-z0-9]+$/i,O=/^\d+$/,k=(e,t,n,r)=>t&&O.test(r)||confirm(`The URL "${e}" does not look like an URL identifying a single toot.

Use it nevertheless?

(The mastodon instance would be "${n}" and the toot id would be "${r}".)`)?[n,r]:void 0;function*A(e,t=[]){if(t===null){yield e;return}let r=e.indexOf(`:`,0);if(r<0){yield e;return}let i=0;for(;;){let a=r+1,o=e.indexOf(`:`,a);if(o===a){r++;continue}if(o<0)break;let s=e.substring(a,o),c=t.find(e=>e.shortcode===s);if(!c){if(r=o,(r=e.indexOf(`:`,r+1))<0)break;continue}if(yield e.substring(i,r),yield n(`img.custom-emoji`,{src:c.static_url,alt:s,title:s,draggable:!1}),i=o+1,r=e.indexOf(`:`,i),r<0)break}yield e.substring(i)}function j(e){function t(n){for(let r of n.childNodes)if(r instanceof HTMLElement)t(r);else if(r instanceof Text){let t=[...A(r.data,e)];if(t.length===1&&typeof t[0]==`string`)continue;let i=new DocumentFragment;i.append(...t),n.replaceChild(i,r)}else console.error(`unexpected value to emojify:`,r)}return t}var M=e=>e?new Date(e).toLocaleString(`sv`):`-`;export{S as a,C as c,d,i as f,T as i,x as l,j as n,w as o,A as r,h as s,M as t,f as u};